# goit-algo-hw-08

# Домашнє завдання до теми “Купи, або піраміди”

## 1. Об'єднання мережевих кабелів
**Задача:** *Є декілька мережевих кабелів різної довжини. Їх потрібно об'єднати по два за раз в один, щоб загальні витрати на з'єднання були мінімальними. Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин.*

### Стратегія розв'язання:
Щоб мінімізувати загальні витрати, на кожному кроці необхідно з'єднувати два найкоротші з наявних кабелів.  Цей підхід гарантує оптимальний результат.

Для ефективної реалізації цієї стратегії ідеально підходить мінімальна купа (**min-heap**). Ця структура даних дозволяє дуже швидко (за час `O(log n)`) отримувати елемент з найменшим значенням. Ми будемо використовувати модуль `heapq` в Python, який реалізує саме мінімальну купу.
Загальна часова складність алгоритму становить `O(n log n)`, де `n` — початкова кількість кабелів.

### Алгоритм:
1. Створити мінімальну купу з довжин усіх кабелів. 
2. Поки в купі більше одного елемента, повторювати:
    - Витягнути з купи два кабелі з найменшою довжиною. 
    - Обчислити вартість їх з'єднання (суму їх довжин) і додати її до загальних витрат. 
    - Додати новий, об'єднаний кабель (довжина якого дорівнює вартості з'єднання) назад у купу. 
3. Повернути загальні витрати.

### Приклад виконання
**Розглянемо набір кабелів з довжинами: `[4, 3, 2, 6]`**

1. **Крок 1:** З'єднуємо два найкоротші кабелі: `2` і `3`.
	- Витрати на цьому кроці: `2 + 3 = 5`.
	- Загальні витрати: `5`.
	- Набір кабелів тепер: `[4, 6, 5]`.

2. **Крок 2:** З'єднуємо два найкоротші з поточних кабелів: `4` і `5`.
	- Витрати на цьому кроці: `4 + 5 = 9`.
	- Загальні витрати: `5 + 9 = 14`.
	- Набір кабелів тепер: `[6, 9]`.

3.  **Крок 3:** З'єднуємо останні два кабелі: `6` і `9`.
	- Витрати на цьому кроці: `6 + 9 = 15`.
	- Загальні витрати: `14 + 15 = 29`.
	- Набір кабелів тепер: `[15]`


```python
import heapq

def min_cost_to_connect_cables(cables):
    """
    Обчислює мінімальні витрати на об'єднання кабелів.

    Args:
        cables (list): Список довжин кабелів.

    Returns:
        int: Мінімальні загальні витрати.
        
    Часова складність: O(n log n), де n - кількість кабелів.
    """
    # Перевірка базового випадку. `len(cables) < 2` є достатньою.
    if len(cables) < 2:
        return 0

    # Перетворюємо список на мінімальну купу "на місці" (in-place).
    # Це ефективно і достатньо для даного завдання.
    heapq.heapify(cables)

    total_cost = 0

    # Поки в купі більше одного кабелю
    while len(cables) > 1:
        # Витягуємо два найкоротші кабелі
        first = heapq.heappop(cables)
        second = heapq.heappop(cables)

        # Вартість поточного з'єднання
        cost = first + second
        total_cost += cost

        # Додаємо новий (об'єднаний) кабель назад у купу
        heapq.heappush(cables, cost)

    return total_cost

# Приклад використання:
cable_lengths = [4, 3, 2, 6]
print(f"Довжини кабелів: {cable_lengths}")
# Важливо: функція змінить цей список.
cost = min_cost_to_connect_cables(cable_lengths)
print(f"Мінімальні витрати на з'єднання: {cost}")
print(f"Список кабелів після виконання функції: {cable_lengths}")
```

#### Вивід:

    Довжини кабелів: [4, 3, 2, 6]
    Мінімальні витрати на з'єднання: 29
    Список кабелів після виконання функції: [15]

------------

## 2. Злиття k відсортованих списків (Необов'язкове завдання)
**Задача:** *Дано **k** відсортованих списків цілих чисел. Завдання — об'єднати їх у один відсортований список.*

### Стратегія розв'язання:
Для ефективного злиття кількох відсортованих списків оптимально використовувати мінімальну купу (`min-heap`). Ідея полягає в тому, щоб у купі одночасно зберігати по одному елементу від кожного списку. На вершині купи завжди буде глобально найменший елемент серед усіх кандидатів.

Коли ми витягуємо найменший елемент з купи і додаємо його до результуючого списку, ми одразу ж додаємо до купи наступний елемент з того ж списку, з якого було взято попередній. Це дозволяє підтримувати процес, доки всі елементи з усіх списків не будуть оброблені.

### Алгоритм:
1. Створити порожню мінімальну купу.
2. Додати до купи перший елемент з кожного непорожнього списку. Разом зі значенням зберігати індекс списку та індекс самого елемента, щоб знати, звідки він прийшов.
3. Поки купа не порожня, повторювати:
    - Витягнути з купи елемент з найменшим значенням.
    - Додати це значення до результуючого списку.
    - Якщо у списку, звідки було взято елемент, є ще елементи, додати наступний елемент з цього списку до купи.
4. Повернути результуючий список, який буде містити всі елементи в відсортованому порядку.

### Аналіз складності
- Часова складність: `O(N log k)`, де `N` — загальна кількість усіх елементів, а `k` — кількість списків. Кожен з `N` елементів буде один раз доданий до купи та один раз витягнутий з неї. Розмір купи ніколи не перевищує `k`, тому кожна операція з купою займає `O(log k)` часу.
- Просторова складність: `O(k)` для зберігання елементів у купі. Додатково потрібна пам'ять `O(N)` для збереження результуючого списку.

```python
import heapq
from typing import List, Tuple

def merge_k_lists(lists: List[List[int]]) -> List[int]:
    """
    Об'єднує k відсортованих списків в один відсортований список.

    Args:
        lists (List[List[int]]): Список відсортованих списків.

    Returns:
        List[int]: Один об'єднаний відсортований список.
        
    Часова складність: O(N log k), де N - загальна кількість елементів, 
                      а k - кількість списків.
    Просторова складність: O(k) для зберігання купи.
    """
    # Підказки типів для змінних для кращої читабельності
    min_heap: List[Tuple[int, int, int]] = []
    
    for i, lst in enumerate(lists):
        if lst:
            # (значення, індекс_списку, індекс_елемента)
            heapq.heappush(min_heap, (lst[0], i, 0))

    merged_list: List[int] = []

    while min_heap:
        value, list_idx, element_idx = heapq.heappop(min_heap)
        
        merged_list.append(value)

        if element_idx + 1 < len(lists[list_idx]):
            next_element_idx = element_idx + 1
            next_value = lists[list_idx][next_element_idx]
            heapq.heappush(min_heap, (next_value, list_idx, next_element_idx))

    return merged_list

# Приклад використання
lists_to_merge = [[1, 4, 5], [1, 3, 4], [2, 6]]
final_list = merge_k_lists(lists_to_merge)

print(f"Вхідні списки: {lists_to_merge}")
print(f"Відсортований список: {final_list}")
```

#### Вивід:

    Вхідні списки: [[1, 4, 5], [1, 3, 4], [2, 6]]
    Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]

------------
